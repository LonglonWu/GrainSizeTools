# ============================================================================ #
#                                                                              #
#    GrainSizeTools Script                                                     #
#    A Python script for characterizing grain size from thin sections          #
#                                                                              #
#    Copyright (c) 2014-present   Marco A. Lopez-Sanchez                       #
#                                                                              #
#    Licensed under the Apache License, Version 2.0 (the "License");           #
#    you may not use this file except in compliance with the License.          #
#    You may obtain a copy of the License at                                   #
#                                                                              #
#        http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                              #
#    Unless required by applicable law or agreed to in writing, software       #
#    distributed under the License is distributed on an "AS IS" BASIS,         #
#    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
#    See the License for the specific language governing permissions and       #
#    limitations under the License.                                            #
#                                                                              #
#    Version 3.0                                                               #
#    For details see: http://marcoalopez.github.io/GrainSizeTools/             #
#    download at https://github.com/marcoalopez/GrainSizeTools/releases        #
#                                                                              #
#    Requirements:                                                             #
#        Python     v3.6  or higher                                            #
#        Numpy      v1.11 or higher                                            #
#        Matplotlib v2.0 or higher                                             #
#        Scipy      v1.0 or higher                                             #
#        Pandas     v0.16 or higher                                            #
#                                                                              #
# ============================================================================ #

# import grain_size_tools modules
import plots as plots
import averages as averages
import stereology as stereology
import tools as tools
import calc as calc
from piezometers import quartz, olivine, calcite, feldspar

# import neccesary Python scientific modules
import numpy as np
from pandas import read_csv, read_excel, DataFrame
from scipy.stats import sem, t, norm


def extract_column(file_path='auto', col_name='Area'):
    """ Extract the data corresponding to a specific column in tabular-like
    text files generated by the ImageJ or similar applications. Files can be
    in plain text (.txt, .csv) or excel (.xlsx) format

    Parameters
    ----------
    file_path : string, optional
        the file location in quotes, e.g: 'C:/.../nameOfTheFile.csv'
        If 'auto' the function will ask you for the location of the file
        through a file selection dialog.

    col_name : string, optional
        the name of the column to extract. 'Area' by default.

    Examples
    --------
    >>> my_data = extract_column()
    >>> diameters = extract_column(col_name='diameters')

    Call function
    -------------
    - get_filepath (from tools)

    Returns
    -------
    An array with the column extracted
    """

    if file_path == 'auto':
        file_path = tools.get_filepath()

    if file_path.endswith('.txt'):
        data_frame = read_csv(file_path, sep='\t')
        data_set = np.array(data_frame[col_name])

    elif file_path.endswith('.csv'):
        data_frame = read_csv(file_path)
        data_set = np.array(data_frame[col_name])

    elif file_path.endswith('.xlsx'):
        data_frame = read_excel(file_path)
        data_set = np.array(data_frame[col_name])

    else:
        raise TypeError("Error: The file is not a 'txt', 'csv' or 'xlsx' or the file extension was not specified.")

    print(' ')
    print(data_frame.head())
    print(data_frame.tail())
    print(' ')
    print('column extracted:')
    print('{name} = {data}' .format(name=col_name, data=data_set))
    print('n =', len(data_set))
    print(' ')

    return data_set


def area2diameter(areas, correct_diameter=None):
    """ Calculate the equivalent cirular diameter from sectional areas.

    Parameters
    ----------
    areas : array_like
        the sectional areas of the grains

    correct_diameter : None or positive scalar, optional
        add the width of the grain boundaries to correct the diameters. If
        correct_diameter is not declared no correction is considered.

    Returns
    -------
    A numpy array with the equivalent circular diameters
    """

    # calculate the equivalent circular diameter
    diameters = 2 * np.sqrt(areas / np.pi)

    # diameter correction adding edges (if applicable)
    if correct_diameter is not None:
        diameters += correct_diameter

    return diameters


def calc_grain_size(diameters, plot='lin', binsize='auto',
                    bandwidth='silverman', precision=None):
    """ Estimate different grain size statistics from a population
    grain sections and plot the location of these measures along with
    the apparent grain size distribution. Includes different means,
    the median, and the frequency peak grain size via KDE.

    Parameters
    ----------
    diameters : array_like
        the apparent diameters of the grains

    plot : string, optional
        the scale/type of the plot and grain size estimation.

        | Types:
        | 'lin' frequency vs linear diameter distribution
        | 'log' frequency vs logarithmic (base e) diameter distribution
        | 'log10' frequency vs logarithmic (base 10) diameter distribution
        | 'sqrt' frequency vs square root diameter distribution
        | 'norm' normalized grain size distribution

    binsize : string or positive scalar, optional
        If 'auto', it defines the plug-in method to calculate the bin size.
        When integer or float, it directly specifies the bin size.
        Default: the 'auto' method.

        | Available plug-in methods:
        | 'auto' (fd if sample_size > 1000 or Sturges otherwise)
        | 'doane' (Doane's rule)
        | 'fd' (Freedman-Diaconis rule)
        | 'rice' (Rice's rule)
        | 'scott' (Scott rule)
        | 'sqrt' (square-root rule)
        | 'sturges' (Sturge's rule)

    bandwidth : string {'silverman' or 'scott'} or positive scalar, optional
        the method to estimate the bandwidth or a scalar directly defining the
        bandwidth. It uses the Silverman plug-in method by default.

    precision : positive scalar or None, optional
        the maximum precision expected for the "peak" kde-based estimator.
        Default is None

    Call functions
    --------------
    - calc_freq_grainsize (from tools.py)
    - calc_areaweighted_grainsize (from tools.py)
    - norm_grain_size (from tools.py)

    Examples
    --------
    >>> calc_grain_size(diameters)
    >>> calc_grain_size(diameters, plot='log')
    >>> calc_grain_size(diameters, areas, plot='area')
    >>> calc_grain_size(diameters, binsize='doane', bandwidth=2.5)
    >>> calc_grain_size(diameters, bandwidth='scott', precision=0.1)
    >>> calc_grain_size(diameters, plot='norm')

    Returns
    -------
    A plot with the distribution of apparent grain sizes and several
    statistical parameters
    """

    # determine the grain size parameters using number-weighted approaches
    if plot == 'lin':
        if precision is None:
            precision = 0.1
        return tools.calc_freq_grainsize(diameters, binsize, plot='linear',
                                         bandwidth=bandwidth,
                                         max_precision=precision)

    elif plot == 'log':
        if precision is None:
            precision = 0.01
        diameters = np.log(diameters)
        return tools.calc_freq_grainsize(diameters, binsize, plot='log',
                                         bandwidth=bandwidth,
                                         max_precision=precision)

    elif plot == 'log10':
        if precision is None:
            precision = 0.01
        diameters = np.log10(diameters)
        return tools.calc_freq_grainsize(diameters, binsize, plot='log10',
                                         bandwidth=bandwidth,
                                         max_precision=precision)

    elif plot == 'norm':
        if precision is None:
            precision = 0.01
        diameters = tools.norm_grain_size(diameters, bandwidth=bandwidth,
                                          binsize=binsize)
        return tools.calc_freq_grainsize(diameters, binsize, plot='norm',
                                         bandwidth=bandwidth,
                                         max_precision=precision)

    elif plot == 'sqrt':
        if precision is None:
            precision = 0.01
        diameters = np.sqrt(diameters)
        return tools.calc_freq_grainsize(diameters, binsize, plot='sqrt',
                                         bandwidth=bandwidth,
                                         max_precision=precision)

    # determine the grain size using the area-weighted approach
    elif plot == 'area':
        if areas is None:
            raise Exception('You must provide the areas of the grain sections!')
        else:
            return tools.calc_areaweighted_grainsize(areas, diameters, binsize)

    else:
        raise ValueError("The type of plot has been misspelled, please use 'lin', 'log', 'log10', 'sqrt', 'norm', or 'area'")


def confidence_interval(data, confidence=0.95):
    """Estimate the confidence interval using the t-distribution with n-1
    degrees of freedom t(n-1). This is the way to go when sample size is
    small (n < 30) and the standard deviation cannot be estimated accurately.
    For large datasets, the t-distribution approaches the normal distribution.

    Parameters
    ----------
    data : array-like
        the dataset

    confidence : float between 0 and 1, optional
        the confidence interval, default = 0.95

    Assumptions
    -----------
    the data follows a normal or a symmetric distrubution (when sample size
    is large)

    call_function(s)
    ----------------
    Scipy's t.interval

    Returns
    -------
    None
    """

    degrees_freedom = len(data) - 1
    sample_mean = np.mean(data)
    std_err = sem(data)  # Standard error of the mean SD / sqrt(n)
    low, high = t.interval(confidence, degrees_freedom, sample_mean, std_err)
    err = high - sample_mean

    print(' ')
    print('Confidence set at {} %' .format(confidence * 100))
    print('Mean = {mean:0.2f} ± {err:0.2f}' .format(mean=sample_mean, err=err))
    print('Max / min = {max:0.2f} / {min:0.2f}' .format(max=high, min=low))
    print('Coefficient of variation = {:0.1f} %' .format(100 * err / sample_mean))

    return None


def calc_diffstress(grain_size, phase, piezometer, correction=False):
    """ Apply different piezometric relations to estimate the differential
    stress from average apparent grain sizes. The piezometric relation has
    the following general form:

    df = B * grain_size**-m

    where df is the differential stress in [MPa], B is an experimentally
    derived parameter in [MPa micron**m], grain_size is the aparent grain
    size in [microns], and m is an experimentally derived exponent.

    Parameters
    ----------
    grain_size : positive scalar
        the apparent grain size in microns

    phase : string {'quartz', 'olivine', 'calcite', or 'feldspar'}
        the mineral phase

    piezometer : string
        the piezometric relation to be use

    correction : bool, default False
        correct the stress values for plane stress (Paterson and Olgaard, 2000)

     References
    -----------
    Paterson and Olgaard (2000) https://doi.org/10.1016/S0191-8141(00)00042-0
    de Hoff and Rhines (1968) Quantitative Microscopy. Mcgraw-Hill. New York.

    Call functions
    --------------
    quartz, olivine, calcite, and albite from piezometers.py

    Assumptions
    -----------
    - Independence of temperature (excepting Shimizu piezometer), total strain,
    flow stress, and water content.
    - Recrystallized grains are equidimensional or close to equidimensional when
    using a single section.
    - The piezometer relations requires entering the grain size as "average"
    apparent grain size values calculated using equivalent circular diameters
    (ECD) with no stereological correction. See documentation for more details.
    - When required, the grain size value will be converted from ECD to linear
    intercept (LI) using a correction factor based on de Hoff and Rhines (1968):
    LI = (correction factor / sqrt(4/pi)) * ECD
    - Stress estimates can be corrected from uniaxial compression (experiments)
    to plane strain (nature) multiplying the paleopiezometer by 2/sqrt(3)
    (Paterson and Olgaard, 2000)

    Returns
    -------
    The differential stress in MPa (a float)
    """

    if phase == 'quartz':
        B, m, warn, linear_interceps, correction_factor = quartz(piezometer)
    elif phase == 'olivine':
        B, m, warn, linear_interceps, correction_factor = olivine(piezometer)
    elif phase == 'calcite':
        B, m, warn, linear_interceps, correction_factor = calcite(piezometer)
    elif phase == 'feldspar':
        B, m, warn, linear_interceps, correction_factor = feldspar(piezometer)
    else:
        raise ValueError('Phase name misspelled. Please choose between valid mineral names')

    # Special cases (convert from ECD to linear intercepts)
    if linear_interceps is True:
        grain_size = (correction_factor / (np.sqrt(4 / np.pi))) * grain_size

    # Estimate differential stress
    if piezometer == 'Shimizu':
        T = float(input("Please, enter the temperature [in C degrees] during deformation: "))
        diff_stress = B * grain_size**(-m) * np.exp(698 / (T + 273.15))
        if correction is True:
            diff_stress = diff_stress * 2 / np.sqrt(3)
        print(' ')
        print('differential stress = {:0.2f} MPa' .format(diff_stress))
        print(warn)
    else:
        diff_stress = B * grain_size**-m
        if correction is True:
            diff_stress = diff_stress * 2 / np.sqrt(3)
        print(' ')
        print('differential stress = {:0.2f} MPa' .format(diff_stress))
        print(warn)
        print(' ')

    return None





welcome = """
======================================================================================
Welcome to GrainSizeTools script v3.0
======================================================================================
GrainSizeTools is a free open-source cross-platform script to visualize and characterize
the grain size in polycrystalline materials from thin sections and estimate differential
stresses via paleopizometers.
"""
functions_list = """
METHODS AVAILABLE
==================  ==================================================================
List of functions   Description
==================  ==================================================================
area2diameter       Estimate the equivalent circular diameter from area sections
calc_diffstress     Estimate diff. stress from grain size using piezometers
calc_grain_size     Estimate the apparent grain size and visualize their distribution
calc_shape          Characterize the log shape of the actual grain size distribution
confidence_interval Estimate a robust confidence interval using the t-distribution
extract_column      Extract data from tabular-like text files (txt, csv or xlsx)
Saltykov            Estimate the actual grain size distribution via the Saltykov method
test_lognorm        Test the lognormality of the distribution using a q-q plot
==================  ==================================================================

You can get more information about the methods in the following ways:
    (1) Typing help plus the name of the function e.g. help(calc_shape)
    (2) In the Spyder IDE by writing the name of the function and clicking Ctrl + I
    (3) Visiting the script documentation at https://marcoalopez.github.io/GrainSizeTools/
    (4) Get a list of the methods available: print(functions_list)
"""

print(welcome)
print(functions_list)

if float(np.__version__[0:4]) < 1.11:
    print('The installed Numpy version', np.__version__, 'is too old.')
    print('Please upgrade to v1.11 or higher')

# ============================================================================ #
# Make it correct, make it clear, make it concise, make it fast. In that order.#
#                                                                     Wes Dyer #
# ============================================================================ #
